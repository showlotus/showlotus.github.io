---
title: 流式加载下的滚动体验优化
tags:
  - 待发布
mathjax: false
date: 2025-11-28 11:30:53
categories:
---

在流式加载场景下，每当流式加载有输出新内容时，会自动滚动到页面底部，以展示最新内容。这是在用户不介入的前提下的默认行为。

而当用户开始介入，想要查看历史内容时，需要手动向上滚动，以查看历史内容。这时，如果再自动滚动到页面底部，就会打断用户的阅读节奏，影响用户体验。所以，需要在用户手动滚动时，停止自动滚动的行为。而如果停止自动滚动后，用户又想看最新的内容，由于自动滚动已被停止了，所以就不得不每次都要手动滚动到页面底部。这种体验也是不好的。因此，还需要在一个合适的时机再次恢复自动滚动的行为。

当在用市面上一些大模型产品时，不知道你是否注意到，目前这些产品在流式加载时，都会在用户手动滚动时，停止自动滚动的行为。而当用户手动滚动到页面底部时，会重新恢复自动滚动的行为。这种体验是很好的。

<!-- ![](demo.gif) -->

而这种效果是如何实现的呢？关键点就在于：**当前滚动条是否在底部**。

基于这个关键点，先来看一下整个流程的各个步骤。

![](flow1.excalidraw.svg)

对于每次新内容的输出，都会有一次判断：滚动条是否在页面底部。如果是，则滚动到底部；否则，不进行滚动。

看到这里，你可能会疑惑：既然都输出新内容了，那么滚动条肯定不在底部了，这个判断有必要吗？

这里的滚动条是否在底部，不是当前实际的滚动条是否处于底部。而是流式内容输出前，当前滚动条是否在底部。如果在底部，则继续保持滚动条处于底部状态，所以需要滚动到底部；否则不处理。在流式输出前会有一次状态记录的操作：

![](flow1-1.excalidraw.svg)

<!-- 那为什么不把 **滚动条是否在底部** 的这个判断放到流式内容输出前呢？其实也不是不行，但是这样做的话，就会导致关于滚动条的判断与业务逻辑强耦合在一起，提升代码的复杂度。试想一下，在接口调用成功后，还需要记录当前滚动条是否在底部，然后再输出新的内容，最后根据记录的状态来判断是否需要滚动到底部，这样就会导致代码的复杂度提升，而且不利于后续的维护。 -->

也就意味着，需要有一个变量来记录这个状态。那么这个变量的初始值是 `true` 还是 `false` 呢？

假设初始状态为 `false`，

先来看下当用户不介入时，

<!-- 如果在底部，则滚动到底部，否则，不滚动到底部。 -->

每当有新内容输出时，都会自动滚动到页面底部。而当不再有新内容输出时，则会停止自动滚动的行为。

也就是每一次新内容的输出都会有一次自动滚动的行为。

仔细分析就会发现，自动滚动是与流式输出新内容相关联的，

而当用户手动滚动时，则会影响下面这个节点的状态：

![](flow2.excalidraw.svg)

但是不会影响整个流程，

虽然用户可以介入的流程节点有更多，但是并非这些流程节点都需要关注，只需要关注触发自动滚动的这个流程节点即可。

![](flow3.excalidraw.svg)

因为只有在这个流程节点中，自动滚动才会和用户的滚动操作产生冲突，其他流程节点中，是不会触发自动滚动的。

```ts
export interface ScrollManagerOptions {
  /**
   * 滚动阈值，当滚动距离小于阈值时，认为到达底部
   */
  threshold?: number
}

export class ScrollManager {
  private container: HTMLElement | null
  private threshold: number
  private isAtBottom: boolean

  constructor(container: HTMLElement, options: ScrollManagerOptions = {}) {
    // 参数校验
    if (!container || !(container instanceof HTMLElement)) {
      throw new Error('container 必须是有效的 DOM 元素')
    }

    this.container = container
    this.threshold = Math.max(0, options.threshold ?? 10)
    this.isAtBottom = this.checkIsAtBottom()
    this.init()
  }

  private init(): void {
    if (!this.container) return

    this.container.addEventListener('scroll', this.handleScroll, {
      passive: true
    })
  }

  // 检查是否在底部
  private checkIsAtBottom(): boolean {
    if (!this.container) return true

    return (
      Math.abs(
        this.container.scrollTop +
          this.container.clientHeight -
          this.container.scrollHeight
      ) < this.threshold
    )
  }

  // 滚动事件处理
  private handleScroll = (): void => {
    this.isAtBottom = this.checkIsAtBottom()
  }

  // 如果当前在底部，则滚动到底部
  public scrollToBottomIfNeeded(): void {
    if (this.isAtBottom) {
      this.scrollToBottom()
    }
  }

  // 滚动到底部
  public scrollToBottom(): void {
    if (!this.container) return

    this.container.scrollTop = this.container.scrollHeight
    this.isAtBottom = true
  }

  // 销毁实例
  public destroy(): void {
    if (!this.container) return

    this.container.removeEventListener('scroll', this.handleScroll)
    this.container = null
  }
}
```
