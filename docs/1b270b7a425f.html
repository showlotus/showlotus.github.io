<!DOCTYPE html><html class="appearance-light" lang="zh-CN"><head><meta charset="UTF-8"><title>重复请求优化</title><meta name="description" content="I hope one day, everyone is using my program."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="设想一种场景，有两个组件，这两个组件在初始化阶段，都需要调用同一个 API 接口去获取数据。为了防止请求冗余，可以把两个组件的请求都挪到父组件中，由父组件统一调用一次请求，然后再将响应的数据结果传给两个子组件。这种方法应该是最常见的，不过它也有一个局限性条件：两个组件必须有一个共同的祖先组件，如果这两个组件是同级的兄弟组件倒也还好，如果非同级，那么数据的传参就会有些麻烦了。那么还有其他办法吗？当然是有的。
我们可以换个思路，每个组件还是保持原有的业务逻辑不变，从请求接口处做文章。既然是同一个接口调用了两次，而且还是返回了相同的请求结果，那么不妨在第一次时调用成功时，就把请求结果缓存起来，等到第二次再调用时，直接返回缓存的数据。按照这个思路可以写出第一版的代码（这里用了 TS 方便查看参数的类型）：
/**
.."><meta name="generator" content="Hexo 5.4.2"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">showlotus's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">重复请求优化</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile is-hidden"></div><div class="column is-9"><header class="my-4"><a href="/tags/JavaScript"><i class="tag post-item-tag">JavaScript</i></a><a href="/tags/%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><i class="tag post-item-tag">工具函数</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">重复请求优化</h1><time class="has-text-grey custom-date-font" datetime="2023-10-02T15:11:03.000Z">2023/10/02 15:11</time><article class="mt-2 post-content"><p>设想一种场景，有两个组件，这两个组件在初始化阶段，都需要调用同一个 <em>API</em> 接口去获取数据。为了防止请求冗余，可以把两个组件的请求都挪到父组件中，由父组件统一调用一次请求，然后再将响应的数据结果传给两个子组件。这种方法应该是最常见的，不过它也有一个局限性条件：两个组件必须有一个共同的祖先组件，如果这两个组件是同级的兄弟组件倒也还好，如果非同级，那么数据的传参就会有些麻烦了。那么还有其他办法吗？当然是有的。</p>
<p>我们可以换个思路，每个组件还是保持原有的业务逻辑不变，从请求接口处做文章。既然是同一个接口调用了两次，而且还是返回了相同的请求结果，那么不妨在第一次时调用成功时，就把请求结果缓存起来，等到第二次再调用时，直接返回缓存的数据。按照这个思路可以写出第一版的代码（这里用了 <em>TS</em> 方便查看参数的类型）：</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/**
 * 缓存请求的响应结果
 * 把发起请求的 Promise 对象挂载在原型对象上
 * @param request 请求函数
 */</span>
<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">cacheRequest</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">request</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"cache"</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<ul>
<li>首先 <code>cacheRequest</code> 函数，需要接收一个参数 <code>request</code>，<code>request</code> 是一个返回结果为 <em>Promise</em> 对象的函数。<code>cacheRequest</code> 执行完后返回一个新的匿名函数。</li>
<li>然后，在匿名函数的内部，先判断 <code>request</code> 的原型对象上是否有 <code>cache</code>（这里的 <code>cache</code> 使用了 <code>Symbol</code> 类型，确保键名唯一）。也即，是否有缓存过的请求结果，如果没有，说明是第一次调用，则将 <code>request</code> 的执行结果存到缓存里。如果有缓存，则直接返回缓存。</li>
<li>可以看到，缓存也是一个 <em>Promise</em> 类型。在同时调用多次请求时，只要在第一次调用执行后，已经把 <em>Promise</em> 存到缓存里了，后续的请求返回的也是缓存里的 <code>Promise</code>，从而保证多个请求都指向同一个 <em>Promise</em> ，也即只会调用一次 <em>API</em> 接口。</li>
<li>这里需要注意一点，由于需要往 <code>request</code> 的原型对象上挂载缓存，所以 <code>request</code> 不能是箭头函数。因为箭头函数没有 <code>this</code>，也就意味着没有原型对象。</li>
</ul>
<p>小测一下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">cacheRequest</span><span class="token punctuation">(</span><span class="token parameter">request</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"cache"</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> <span class="token function-variable function">request</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"fetch request"</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> newRequest <span class="token operator">=</span> <span class="token function">cacheRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>

<span class="token function">newRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">newRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">newRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p><img src="/1b270b7a425f/version1.png" alt="Alt text"></p>
<p>可以看到虽然 <code>newRequest</code> 调用了三次，但是 <code>fetch request</code> 只打印了一次，也就是说 <code>request</code> 只调用了一次，符合预期！但是，最后一次 <code>newRequest</code> 的调用，是在 <em>3</em> 秒后调用的，也是走的缓存，没有重新执行。仔细思考一下，后续无论什么时候调用 <code>newRequest</code> 都会使用缓存里的数据，不会重新调用请求了，这显然是不合理的。我们还需要加个缓存的过期时间，超过这个时间，就重新发起新的请求。第二版如下：</p>
<pre class="language-typescript" data-language="typescript"><code class="language-typescript"><span class="token comment">/**
 * 缓存请求的响应结果
 * 把发起请求的 Promise 对象挂载在原型对象上
 * 保证在 cacheTime 时间间隔内的多次请求，只会调用一次
 * @param request 请求函数
 * @param cacheTime 最大缓存时间（单位毫秒）
 */</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">cacheRequest</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function-variable function">request</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span> cacheTime <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"cache"</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> lastTime <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"lastTime"</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span> <span class="token operator">||</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>lastTime<span class="token punctuation">]</span> <span class="token operator">>=</span> cacheTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
      request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>lastTime<span class="token punctuation">]</span> <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<ul>
<li>首先，<code>cacheRequest</code> 新增一个入参 <code>cacheTime</code>，用于设置过期时间，默认为 <em>1</em> 秒。</li>
<li>其次，在原型对象上新增了一个 <code>lastTime</code> 属性，用来记录最后一次调用的时间。</li>
<li>当缓存为空，或者当前时间距离上一次调用时间超过缓存过期时间时，更新 <code>cache</code> 和 <code>lastTime</code> 。</li>
</ul>
<p>再来小测一下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">cacheRequest</span><span class="token punctuation">(</span><span class="token parameter">request<span class="token punctuation">,</span> cacheTime <span class="token operator">=</span> <span class="token number">1000</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"cache"</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> lastTime <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"lastTime"</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span> <span class="token operator">||</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>lastTime<span class="token punctuation">]</span> <span class="token operator">>=</span> cacheTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
      request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>lastTime<span class="token punctuation">]</span> <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> request<span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>cache<span class="token punctuation">]</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> <span class="token function-variable function">request</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"fetch request"</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">const</span> newRequest <span class="token operator">=</span> <span class="token function">cacheRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>

<span class="token function">newRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">newRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span>newRequest<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span></code></pre>

<p><img src="/1b270b7a425f/version2.png" alt="Alt text"></p>
<p>这一次，<code>fetch request</code> 打印了两次，符合预期，完美！</p>
<blockquote>
<p>2024&#x2F;10&#x2F;25 更新：入参 <code>request</code> 支持箭头函数。</p>
</blockquote>
<pre class="language-diff" data-language="diff"><code class="language-diff">function cacheRequest(request, cacheTime = 1000) &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> const cache = Symbol("cache")
</span><span class="token prefix unchanged"> </span><span class="token line"> const lastTime = Symbol("lastTime")
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> return function (...args) &#123;
</span><span class="token prefix deleted">-</span><span class="token line">   if (!request.prototype[cache] || Date.now() - request.prototype[lastTime] >= cacheTime) &#123;
</span><span class="token prefix deleted">-</span><span class="token line">     request.prototype[cache] = request(...args)
</span><span class="token prefix deleted">-</span><span class="token line">     request.prototype[lastTime] = Date.now()
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> return function innerFn(...args) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">   if (!innerFn.prototype[cache] || Date.now() - innerFn.prototype[lastTime] >= cacheTime) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">     innerFn.prototype[cache] = request(...args)
</span><span class="token prefix inserted">+</span><span class="token line">     innerFn.prototype[lastTime] = Date.now()
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   &#125;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">   return request.prototype[cache]
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   return innerFn.prototype[cache]
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> &#125;
</span></span>&#125;</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/56f897d68ca6.html" title="Mac 开发环境搭建（持续更新中～）"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: Mac 开发环境搭建（持续更新中～）</span></a><a class="button is-default" href="/6247c0cb9321.html" title="最大余额法"><span class="has-text-weight-semibold">下一页: 最大余额法</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="showlotus/showlotus" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- TODO 配置个人网站链接--><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/showlotus"><i class="iconfont icon-github"></i></a><!-- Gitee--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> showlotus 2025</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@2.1.4/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js"></script><script src="/js/clipboard_use.js"></script><script src="/js/codepen.io.js"></script></body></html>